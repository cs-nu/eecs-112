
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <title>Quiz 1 Review Â· GitBook</title>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.0">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-prism/prism.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="styles/website.css">
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    
    <link rel="prev" href="2-Filter.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                        <b>1.1.</b>
                    
                    Introduction
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Notes</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="0-Expressions-Calls.html">
            
                <a href="0-Expressions-Calls.html">
            
                    
                        <b>2.1.</b>
                    
                    Expressions and Function Calls
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="0-Function-Composition.html">
            
                <a href="0-Function-Composition.html">
            
                    
                        <b>2.2.</b>
                    
                    Function Composition
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="0-Types.html">
            
                <a href="0-Types.html">
            
                    
                        <b>2.3.</b>
                    
                    Types
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.4" data-path="0-Signatures.html">
            
                <a href="0-Signatures.html">
            
                    
                        <b>2.4.</b>
                    
                    Function Signatures
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.5" data-path="0-Exercises.html">
            
                <a href="0-Exercises.html">
            
                    
                        <b>2.5.</b>
                    
                    Exercises
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.6" data-path="1-Lambda.html">
            
                <a href="1-Lambda.html">
            
                    
                        <b>2.6.</b>
                    
                    Defining Functions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.7" data-path="2-Structs-Lists.html">
            
                <a href="2-Structs-Lists.html">
            
                    
                        <b>2.7.</b>
                    
                    Structs and Lists
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.8" data-path="2-Map.html">
            
                <a href="2-Map.html">
            
                    
                        <b>2.8.</b>
                    
                    map
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.9" data-path="2-Filter.html">
            
                <a href="2-Filter.html">
            
                    
                        <b>2.9.</b>
                    
                    filter
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Review Sheets</li>
        
        
    
        <li class="chapter active" data-level="3.1" data-path="3-Quiz-1-Review.html">
            
                <a href="3-Quiz-1-Review.html">
            
                    
                        <b>3.1.</b>
                    
                    Quiz 1 Review
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Quiz 1 Review</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="quiz-1-review-sheet">Quiz 1 Review Sheet</h1><blockquote><p><strong>Fall 2016 Note:</strong> This is not a comprehensive review. Namely, it does not cover the <code>cs111/iterated</code> library, nor does it cover <code>andmap</code> and <code>ormap</code>. Examples are minimal; for more in-depth explanations, see the <a href="http://sarahlim.com/eecs-111" target="_blank">recitation notes</a>.</p></blockquote><h2 id="primitive-types">Primitive Types</h2><p>Programs are made up of data objects, which are categorized into types. <strong>Primitive types</strong> are categories of data objects that can&apos;t be divided into <em>different</em> types.</p><ul><li><p><strong>Numbers</strong> are made up of digits and symbols.</p><ul><li>Examples: <code>10</code>, <code>3/2</code>, <code>-94.6</code>, <code>pi</code>
</li></ul>
</li>
<li><p><strong>Strings</strong> are sequences of characters enclosed by a pair of double quotes (<code>&quot;</code>).</p><ul><li>Examples: <code>&quot;hello world&quot;</code>, <code>&quot;a&quot;</code>, <code>&quot;10&quot;</code>, <code>&quot;\&quot;YOLO!\&quot; he screamed.&quot;</code>
</li></ul>
</li>
<li><p><strong>Booleans</strong> are logical values. They are one of:</p><ul><li><code>true</code> (equivalently, <code>#true</code>, <code>#t</code>, or <code>#T</code>)
</li>
<li><code>false</code> (equivalently, <code>#false</code>, <code>#f</code>, or <code>#F</code>)
</li></ul>
</li></ul>
<h2 id="images">Images</h2><p><strong>Images</strong> are exactly what you think they are. Working with images in Racket typically requires the <code>2htdp/image</code> teachpack, which can be imported using</p><pre><code class="lang-scheme"><span class="token punctuation">(</span><span class="token function">require</span> 2htdp/image<span class="token punctuation">)</span></code></pre>
<p>Here are some examples of images:</p><table>
<thead>
<tr><th>Output</th>
<th>Equivalent Code</th>
</tr></thead><tbody>
<tr><td><img alt="red circle overlaid on blue circle" src="https://cloudup.com/c5LGdRMHDuU+"></td>
<td><code>(overlay (circle 10 &quot;solid&quot; &quot;red&quot;) (circle 20 &quot;solid&quot; &quot;blue&quot;))</code></td>
</tr><tr><td><img alt="green ellipse rotated 45 degrees" src="https://cloudup.com/cuyXSaNR_C1+"></td>
<td><code>(rotate 45 (ellipse 60 20 &quot;solid&quot; &quot;green&quot;))</code></td>
</tr><tr><td><img alt="picture of Rick Astley" src="http://66.media.tumblr.com/avatar_369b115beb6e_128.png"></td>
<td>copy and pasted from Google Images</td>
</tr></tbody></table>

<h2 id="structs">Structs</h2><p><strong>Structs</strong> (also called <strong>records</strong>) are more complex data types. They can be thought of as custom &quot;templates&quot; for kinds of data.</p><p>Define a new struct using</p><pre><code class="lang-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span>-struct &lt;StructType&gt; <span class="token punctuation">(</span><span class="token operator">&lt;</span>FieldName1&gt; &lt;FieldName2&gt; ... &lt;FieldNameN&gt;<span class="token punctuation">)</span><span class="token punctuation">)</span>

&gt; <span class="token punctuation">(</span><span class="token keyword">define</span>-struct birthday <span class="token punctuation">(</span><span class="token function">day</span> month year<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>When you define a struct, the following functions also become defined:</p><table>
<thead>
<tr><th>Name</th>
<th>Description</th>
<th>Syntax</th>
</tr></thead><tbody>
<tr><td><strong>The &quot;Maker&quot;</strong></td>
<td><code>make-<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>StructType</span><span class="token punctuation">&gt;</span></span></code></td>
<td>Creates a new instance of <code>StructType</code> (you can think of it as &quot;filling out&quot; the template)</td>
</tr><tr><td><strong>The &quot;Validator&quot;</strong></td>
<td><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>StructType</span><span class="token punctuation">&gt;</span></span>?</code></td>
<td>Checks whether some data object is an instance of <code>StructType</code></td>
</tr><tr><td><strong>The &quot;Getter&quot;</strong></td>
<td><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>StructType</span><span class="token punctuation">&gt;</span></span>-<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>FieldName</span><span class="token punctuation">&gt;</span></span></code></td>
<td>Gets a particular field value from an instance of <code>StructType</code></td>
</tr></tbody></table>

<p>The exact signatures for each function are:</p><p><code>make-<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>StructType</span><span class="token punctuation">&gt;</span></span> : FieldType1 FieldType2 ... FieldTypeN -&gt; StructType</code></p><pre><code class="lang-scheme">&gt; <span class="token punctuation">(</span><span class="token keyword">define</span> MY_BIRTHDAY <span class="token punctuation">(</span><span class="token function">make-birthday</span> <span class="token number">10</span> <span class="token string">&quot;August&quot;</span> <span class="token number">1993</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>StructType</span><span class="token punctuation">&gt;</span></span>? : any -&gt; boolean</code></p><pre><code class="lang-scheme">&gt; <span class="token punctuation">(</span><span class="token function">birthday?</span> MY_BIRTHDAY
true
&gt; <span class="token punctuation">(</span><span class="token function">birthday?</span> <span class="token punctuation">(</span><span class="token function">make-birthday</span> <span class="token number">5</span> <span class="token string">&quot;June&quot;</span> <span class="token number">1965</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
true
&gt; <span class="token punctuation">(</span><span class="token function">birthday?</span> <span class="token number">40</span><span class="token punctuation">)</span>
false</code></pre>
<p><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>StructType</span><span class="token punctuation">&gt;</span></span>-<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>FieldName</span><span class="token punctuation">&gt;</span></span> : StructType -&gt; FieldType</code></p><pre><code class="lang-scheme">&gt; <span class="token punctuation">(</span><span class="token function">birthday-month</span> MY_BIRTHDAY<span class="token punctuation">)</span>
<span class="token string">&quot;August&quot;</span>
&gt; <span class="token punctuation">(</span><span class="token function">birthday-month</span> <span class="token punctuation">(</span><span class="token function">make-birthday</span> <span class="token number">5</span> <span class="token string">&quot;June&quot;</span> <span class="token number">1965</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">&quot;June&quot;</span></code></pre>
<h2 id="lists">Lists</h2><p><strong>Lists</strong> are collections of data objects.</p><pre><code class="lang-scheme"><span class="token punctuation">(</span><span class="token builtin">list</span> &lt;Item1&gt; &lt;Item2&gt; ... &lt;ItemN&gt;<span class="token punctuation">)</span></code></pre>
<p>Lists have types too, denoted using the syntax</p><pre><code class="lang-scheme"><span class="token punctuation">(</span><span class="token function">listof</span> &lt;Type&gt;<span class="token punctuation">)</span></code></pre>
<p>where <code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Type</span><span class="token punctuation">&gt;</span></span></code> is any of the types we&apos;ve already seen, or <code>any</code> if the list contains multiple types.</p><p>Here are examples of lists and their types:</p><table>
<thead>
<tr><th>Example</th>
<th>Type</th>
</tr></thead><tbody>
<tr><td><code>(list 1 2 3 4)</code></td>
<td><code>(listof number)</code></td>
</tr><tr><td><code>(list (circle 10 &quot;solid&quot; &quot;red&quot;) (square 40 &quot;outline&quot; &quot;blue&quot;))</code></td>
<td><code>(listof image)</code></td>
</tr><tr><td><code>(list (list 1 2) (list 3 4)</code></td>
<td><code>(listof (listof number))</code></td>
</tr><tr><td><code>(list 1 2 true)</code></td>
<td><code>(listof any)</code></td>
</tr></tbody></table>

<h2 id="function-signatures">Function Signatures</h2><p><strong>Functions</strong> (also called <strong>procedures</strong>) are data objects that take input data objects (also called &quot;arguments&quot;), and return a data object output. Each function has a <strong>signature</strong> indicating the types of its inputs and outputs.</p><pre><code class="lang-scheme">InputType1 InputType2 ... InputTypeN -&gt; ReturnType</code></pre>
<p>Here are some example signatures:</p><pre><code class="lang-scheme"><span class="token comment" spellcheck="true">; regular functions with set input types and orders</span>
even? : number -&gt; boolean
circle : number string string -&gt; image

<span class="token comment" spellcheck="true">; functions that take an arbitrary number of inputs of a given type</span>
+ : number ... -&gt; number
string-append : string ... -&gt; string

<span class="token comment" spellcheck="true">; functions that take any type</span>
number? : any -&gt; boolean

<span class="token comment" spellcheck="true">; functions that take other functions</span>
iterated-overlay : <span class="token punctuation">(</span><span class="token function">number</span> -&gt; image<span class="token punctuation">)</span> number -&gt; image
map : <span class="token punctuation">(</span><span class="token function">a</span> -&gt; b<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">listof</span> a<span class="token punctuation">)</span> -&gt; <span class="token punctuation">(</span><span class="token function">listof</span> b<span class="token punctuation">)</span></code></pre>
<h2 id="basic-order-of-operations">Basic Order of Operations</h2><p>In Racket, expressions comprised of function calls are simplified according to the following rule:</p><blockquote><p><strong>Evaluate parentheses first</strong> (as deeply nested as necessary), then simplify your way out, working from <strong>left to right</strong> when multiple expressions are nested at the same level.</p></blockquote><h2 id="calling-functions">Calling Functions</h2><p>In Racket, we <strong>call</strong> (or <strong>apply</strong>) functions using the following syntax:</p><pre><code class="lang-scheme"><span class="token punctuation">(</span><span class="token operator">&lt;</span>FunctionName&gt; &lt;InputType1&gt; &lt;InputType2&gt; ... &lt;InputTypeN&gt;<span class="token punctuation">)</span></code></pre>
<p>To break this syntax down in painstaking detail,</p><ol><li><strong>Opening paren</strong> <code>(</code> tells Racket <em>we are calling a function</em>;
</li>
<li><strong><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>FunctionName</span><span class="token punctuation">&gt;</span></span></code></strong>, e.g. <code>+</code>, tells Racket <em>which</em> function;
</li>
<li><strong>Space</strong> between function name and first input;
</li>
<li><strong>Inputs in order, separated by spaces</strong>;
</li>
<li><strong>Closing paren</strong> <code>)</code> tells Racket <em>we are done listing inputs</em>.
</li></ol>
<p>Note that <em>function calls are always enclosed in parentheses <code>()</code></em>. When a function call is evaluated, the <strong>call</strong> <code>(<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>FunctionName</span><span class="token punctuation">&gt;</span></span> ...)</code> gets transformed into its return value.</p><pre><code class="lang-scheme">&gt; <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token number">2</span></code></pre>
<p>This grammatical rule results in the following behaviors:</p><ul><li><p>If a function and series of arguments are <em>not enclosed in parentheses</em>, Racket will not evaluate the function. It will simply return the function object and its arguments, all separately.</p><pre><code class="lang-scheme">  &gt; + <span class="token number">1</span> <span class="token number">1</span>
  +  <span class="token comment" spellcheck="true">; the function object</span>
  <span class="token number">1</span>
  <span class="token number">1</span></code></pre>
<ul><li>If a <em>non-function</em> is enclosed in parentheses, Racket will try to call it (per the rules of the grammar). If the first chunk after the opening paren is not a function name, Racket will throw the following error:
<pre><code class="lang-scheme">&gt; <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token punctuation">(</span>1<span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span>
function call: expected a function after the open parenthesis, but received <span class="token number">1</span></code></pre>
</li></ul>
</li></ul>
<h3 id="using-apply">Using <code>apply</code></h3><p>Instead of calling a function directly,</p><pre><code class="lang-scheme"><span class="token punctuation">(</span><span class="token operator">&lt;</span>FunctionName&gt; &lt;Input1&gt; &lt;Input2&gt; ... &lt;InputN&gt;<span class="token punctuation">)</span></code></pre>
<p>we can use <code>apply</code> to pass in a <em>list of inputs</em>:</p><pre><code class="lang-scheme"><span class="token punctuation">(</span><span class="token builtin">apply</span> &lt;FunctionName&gt; <span class="token punctuation">(</span><span class="token builtin">list</span> &lt;Input1&gt; &lt;Input2&gt; ... &lt;InputN&gt;<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>That is, <code>apply</code> takes two arguments:</p><ol><li><strong><functionname></functionname></strong>, the name of the function to call
</li>
<li><strong>(list <input1> ... <inputn>)</inputn></input1></strong>, the inputs with which to call <code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>FunctionName</span><span class="token punctuation">&gt;</span></span></code>, in the correct order.
</li></ol>
<p>Some functions, such as <code>+</code>, <code>string-append</code>, and <code>overlay</code>, take an arbitrary number of inputs. That is, their signatures are</p><pre><code class="lang-scheme">+ : number ... -&gt; number
string-append : string ... -&gt; string
overlay : image ... -&gt; image</code></pre>
<p>with the ellipses <code>...</code> being the important part.</p><p>We use <code>apply</code> to call these types of functions with a list of elements:</p><pre><code class="lang-scheme">&gt; <span class="token punctuation">(</span><span class="token builtin">apply</span> + <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">6</span>
&gt; <span class="token punctuation">(</span><span class="token builtin">apply</span> string-append <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">&quot;thanks&quot;</span> <span class="token string">&quot; &quot;</span> <span class="token string">&quot;obama&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token string">&quot;thanks obama&quot;</span></code></pre>
<h2 id="defining-constants">Defining Constants</h2><p><strong>Constants</strong> bind identifiers (or &quot;names&quot;) to values.</p><pre><code class="lang-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> &lt;ConstantName&gt; &lt;ConstantValue&gt;<span class="token punctuation">)</span></code></pre>
<ol><li><p><strong><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ConstantName</span><span class="token punctuation">&gt;</span></span></code></strong> is a sequence of non-whitespace characters except for the following:</p><ul><li><code>(</code> <code>)</code> <code>[</code> <code>]</code> <code>{</code> <code>}</code> <code>&quot;</code> <code>&apos;</code> <code>;</code> <code>#</code> <code>|</code> <code>\</code> ` (don&apos;t memorize this list; basically, it&apos;s just any character that would turn the constant name into something else, like a string or function call)
</li>
<li>By convention, Racket constants are formatted in <code>CAPITAL_LETTERS</code> with underscores separating words.
</li></ul>
</li>
<li><p><strong><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ConstantValue</span><span class="token punctuation">&gt;</span></span></code></strong> is any value, ranging from primitive objects to complex expressions.</p></li></ol>
<p>Here are some examples of constant definitions:</p><pre><code class="lang-scheme"><span class="token comment" spellcheck="true">; simple primitives</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> FIRST_NAME <span class="token string">&quot;sarah&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> LAST_NAME <span class="token string">&quot;lim&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> YEAR <span class="token number">2016</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">; expressions</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> NEXT_YEAR <span class="token punctuation">(</span><span class="token operator">+</span> YEAR <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> NICKNAME <span class="token punctuation">(</span><span class="token function">string-append</span> <span class="token punctuation">(</span><span class="token function">substring</span> FIRST_NAME <span class="token number">0</span> <span class="token number">1</span><span class="token punctuation">)</span>
                                LAST_NAME<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">; defining a struct for the next example; this is NOT a constant</span>
<span class="token punctuation">(</span><span class="token keyword">define</span>-struct contact <span class="token punctuation">(</span><span class="token function">first</span> last nickname year-met<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">; non-primitive data types</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> ME <span class="token punctuation">(</span><span class="token function">make-contact</span> FIRST_NAME LAST_NAME NICKNAME YEAR<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> IAN <span class="token punctuation">(</span><span class="token function">make-contact</span> <span class="token string">&quot;ian&quot;</span> <span class="token string">&quot;horswill&quot;</span> <span class="token string">&quot;dumbledore&quot;</span> YEAR<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> CONTACTS <span class="token punctuation">(</span><span class="token builtin">list</span> ME
                       IAN
                       <span class="token punctuation">(</span><span class="token function">make-contact</span> FIRST_NAME <span class="token string">&quot;palin&quot;</span> <span class="token string">&quot;oh no&quot;</span> <span class="token number">2008</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>Constants declared at the outermost level of the program (you can think of this as the &quot;unindented&quot; level) have <strong>global scope</strong>, meaning they can be referenced from anywhere in the program, including within function definitions.</p><h2 id="lambdas">Lambdas</h2><p><strong>Lambdas</strong> create anonymous functions, i.e. functions without names/identifiers.</p><pre><code class="lang-scheme"><span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>Input1&gt; &lt;Input2&gt; ... &lt;InputN&gt;<span class="token punctuation">)</span> &lt;Body&gt;<span class="token punctuation">)</span></code></pre>
<p>A lambda consists of two parts:</p><ol><li>A sequence of <strong>inputs</strong> (also known as <strong>arguments</strong> or <strong>parameters</strong>), <em>enclosed within parens</em> <code>()</code>
</li>
<li>A function <strong>body</strong>, some kind of expression.
</li></ol>
<p>We can <em>call a lambda</em> using the same old rules of function calls:</p><pre><code class="lang-scheme"><span class="token comment" spellcheck="true">; (&lt;FunctionName&gt; &lt;InputType1&gt; &lt;InputType2&gt; ... &lt;InputTypeN&gt;)</span>
&gt; <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">2</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token number">10</span></code></pre>
<p>It&apos;s generally easier (and much more readable) to <strong>define constant names</strong> for our functions, so we can reference them later.</p><pre><code class="lang-scheme"><span class="token comment" spellcheck="true">; (define &lt;ConstantName&gt; &lt;ConstantValue&gt;)</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> doubler
  <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">2</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<h2 id="scoping">Scoping</h2><p>Once we have defined a constant or a function, Racket will automatically plug in <code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ConstantValue</span><span class="token punctuation">&gt;</span></span></code> whenever it sees <code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ConstantName</span><span class="token punctuation">&gt;</span></span></code>.</p><p>The <strong>scope</strong> of a name refers to the parts of a program where this plugging-in behavior works. We&apos;ve dealt with two examples of scopes thus far:</p><ol><li><strong>Global scope:</strong> anything <code>defined</code> at the outermost level of our program can be referenced from within any scope after the definition.
</li>
<li><strong>Function scope:</strong> if a lambda <code>my-cool-function</code> takes inputs <code>a</code> and <code>b</code>, then <code>a</code> and <code>b</code> can be referenced anywhere within the body of the lambda, including any nested inner lambdas. They <em>cannot</em> be referenced outside of <code>my-cool-function</code>.
</li></ol>
<p>If a name <code>my-cool-variable</code> is defined once, then _re_defined in some inner scope, the inner redefinition <strong>shadows</strong> the outer definition, meaning Racket will use the closest definition of <code>my-cool-variable</code> whenever it evaluates our program.</p><pre><code class="lang-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> HEIGHT <span class="token number">5</span><span class="token punctuation">)</span>

HEIGHT  <span class="token comment" spellcheck="true">; 5</span>

<span class="token punctuation">(</span><span class="token keyword">define</span> example-function
  <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>HEIGHT<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">; the name HEIGHT has been redefined within example-function</span>
    <span class="token punctuation">(</span><span class="token operator">+</span> HEIGHT <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token punctuation">(</span><span class="token function">example-function</span> <span class="token number">30</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">; 31</span></code></pre>
<h3 id="local-scoping">Local Scoping</h3><p>It&apos;s a good practice in software engineering to make all your definitions as private as possible, to avoid leaking them out to other parts of the program.</p><p>Suppose we have a helper function or variable specific to a particular function. We can use <code>local</code> to <em>create scopes</em> for these helpers, while keeping them from leaking to other functions.</p><pre><code class="lang-scheme"><span class="token punctuation">(</span><span class="token function">local</span> [&lt;Definition1&gt; &lt;Definition2&gt; ... &lt;DefinitionN&gt;] &lt;Body&gt;<span class="token punctuation">)</span></code></pre>
<p>The keyword <code>local</code> has two parts:</p><ol><li>A <strong>list of definitions</strong> <em>enclosed within square brackets</em>,
</li>
<li>A <strong>body</strong> where these definitions, along with any definitions outside the <code>local</code>, can be referenced.
</li></ol>
<p>The definitions in square brackets cannot be referenced outside the <code>local</code> body.</p><p>Variable shadowing applies to <code>local</code> definitions as well. If <code>my-cool-name</code> is defined globally, and redefined within a <code>local</code> scope, then the body of the <code>local</code> will use the definition in the square brackets instead of the global definition.</p><h2 id="conditionals">Conditionals</h2><p><strong>Conditionals</strong> allow our programs to &quot;branch&quot; based on a series of logical cases.</p><h3 id="if"><code>if</code></h3><p>The simplest conditional branch is <code>if</code>.</p><pre><code class="lang-scheme"><span class="token punctuation">(</span><span class="token keyword">if</span> &lt;Condition&gt; &lt;ThenExpression&gt; &lt;ElseExpression&gt;<span class="token punctuation">)</span></code></pre>
<ul><li><strong><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Condition</span><span class="token punctuation">&gt;</span></span></code></strong> is a boolean expression
</li>
<li><strong><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ThenExpression</span><span class="token punctuation">&gt;</span></span></code></strong> and <strong><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ElseExpression</span><span class="token punctuation">&gt;</span></span></code></strong> are expressions or primitive values of any type.
</li></ul>
<p>When Racket encounters an <code>if</code>, it does the following:</p><ol><li>Evaluate <code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Condition</span><span class="token punctuation">&gt;</span></span></code> by simplifying it down to either <code>true</code> or <code>false</code>
</li>
<li>Based on the result of step 1,
<ul><li>If <code>true</code>, jump to <code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ThenExpression</span><span class="token punctuation">&gt;</span></span></code>
</li>
<li>If <code>false</code>, jump to <code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ElseExpression</span><span class="token punctuation">&gt;</span></span></code>
</li></ul>
</li></ol>
<pre><code class="lang-scheme">&gt; <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">even?</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;2 is even&quot;</span> <span class="token string">&quot;2 is odd&quot;</span><span class="token punctuation">)</span>
<span class="token string">&quot;2 is even&quot;</span>

&gt; <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">&gt;</span> <span class="token number">3</span> <span class="token number">5</span><span class="token punctuation">)</span>
      <span class="token string">&quot;3 is greater than 5&quot;</span>
      <span class="token string">&quot;3 is not greater than 5&quot;</span><span class="token punctuation">)</span>
<span class="token string">&quot;3 is not greater than 5&quot;</span></code></pre>
<h3 id="and"><code>and</code></h3><p>We use the logical operator <code>and</code> to determine if a series of boolean expressions are <em>all</em> true.</p><pre><code class="lang-scheme"><span class="token punctuation">(</span><span class="token function">and</span> &lt;Boolean1&gt; &lt;Boolean2&gt; ... &lt;BooleanN&gt;<span class="token punctuation">)</span> -&gt; Boolean</code></pre>
<p><code>(and A B)</code> is true if and only if <code>A</code> is true <em>and</em> <code>B</code> is true.</p><table>
<thead>
<tr><th>Example</th>
<th>Result</th>
</tr></thead><tbody>
<tr><td><code>(and true true)</code></td>
<td><code>true</code></td>
</tr><tr><td><code>(and true false)</code></td>
<td><code>false</code></td>
</tr><tr><td><code>(and false true)</code></td>
<td><code>false</code></td>
</tr><tr><td><code>(and false false)</code></td>
<td><code>false</code></td>
</tr></tbody></table>

<h3 id="or"><code>or</code></h3><p>We use the logical operator <code>or</code> to determine if <em>at least one</em> expression in series of boolean expressions is true.</p><pre><code class="lang-scheme"><span class="token punctuation">(</span><span class="token function">or</span> &lt;Boolean1&gt; &lt;Boolean2&gt; ... &lt;BooleanN&gt;<span class="token punctuation">)</span> -&gt; Boolean</code></pre>
<p><code>(or A B)</code> is true if and only if <code>A</code> is true <em>or</em> <code>B</code> is true.</p><table>
<thead>
<tr><th>Example</th>
<th>Result</th>
</tr></thead><tbody>
<tr><td><code>(or true true)</code></td>
<td><code>true</code></td>
</tr><tr><td><code>(or true false)</code></td>
<td><code>true</code></td>
</tr><tr><td><code>(or false true)</code></td>
<td><code>true</code></td>
</tr><tr><td><code>(or false false)</code></td>
<td><code>false</code></td>
</tr></tbody></table>

<h3 id="not"><code>not</code></h3><p>We use the logical operator <code>not</code> to &quot;flip&quot; a single boolean value, i.e. get its logical opposite.</p><pre><code class="lang-scheme"><span class="token punctuation">(</span><span class="token function">not</span> &lt;Boolean&gt;<span class="token punctuation">)</span> -&gt; Boolean</code></pre>
<p>The table for <code>not</code> is simple:</p><table>
<thead>
<tr><th>Example</th>
<th>Result</th>
</tr></thead><tbody>
<tr><td><code>(not true)</code></td>
<td><code>false</code></td>
</tr><tr><td><code>(not false)</code></td>
<td><code>true</code></td>
</tr></tbody></table>

<h2 id="lambda-abstractions">Lambda Abstractions</h2><p>It&apos;s useful to be able to perform operations on entire lists of data, rather than one object at a time. Racket gives us several functions to use. Here&apos;s an high-level summary of what each one does:</p><table>
<thead>
<tr><th>Function</th>
<th>Description</th>
<th>Image</th>
</tr></thead><tbody>
<tr><td><code>map</code></td>
<td>Transforms a list by applying a function to each item</td>
<td><img title="map" alt="a series of blue circles transformed into a series of red squares" src="https://dl.dropboxusercontent.com/u/14218448/screenshots/map.png" style="max-width: 200px"></td>
</tr><tr><td><code>filter</code></td>
<td>Filters out items that fail some test</td>
<td><img title="filter" alt="a series of blue circles, some with fill colors, transformed into only the circles with fill colors" src="https://dl.dropboxusercontent.com/u/14218448/screenshots/filter.png" style="max-width: 200px"></td>
</tr><tr><td><code>foldl</code> and <code>foldr</code></td>
<td>Combines everything in a list into a single item</td>
<td><img title="fold" alt="a series of progressively larger circles, transformed into a single image nesting all of the circles together" src="https://dl.dropboxusercontent.com/u/14218448/screenshots/fold.png" style="max-width: 200px"></td>
</tr></tbody></table>

<h3 id="map"><code>map</code></h3><p>The <code>map</code> function allows us to <strong>transform a list</strong>.</p><pre><code class="lang-scheme">map : <span class="token punctuation">(</span><span class="token function">X</span> -&gt; Y<span class="token punctuation">)</span>, <span class="token punctuation">(</span><span class="token function">listof</span> X<span class="token punctuation">)</span> -&gt; <span class="token punctuation">(</span><span class="token function">listof</span> Y<span class="token punctuation">)</span></code></pre>
<p>It takes two inputs:</p><ul><li>A <strong>function</strong> with signature <code>X -&gt; Y</code>, i.e. a function that takes an input of type <code>X</code> and returns an input of type <code>Y</code>, and
</li>
<li>A <strong>list</strong> of elements of type <code>X</code>
</li></ul>
<p>and &quot;maps&quot; the function over each item in the input list, returning a <strong>list</strong> of elements of type <code>Y</code>.</p><pre><code class="lang-scheme">&gt; <span class="token punctuation">(</span><span class="token function">map</span> even? <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token builtin">list</span> false true false true false true<span class="token punctuation">)</span></code></pre>
<h2 id="filter"><code>filter</code></h2><p>The <code>filter</code> function allows us to <strong>filter out elements of a list that don&apos;t match a given criteria</strong>.</p><pre><code class="lang-scheme">filter : <span class="token punctuation">(</span><span class="token function">X</span> -&gt; boolean<span class="token punctuation">)</span>, <span class="token punctuation">(</span><span class="token function">listof</span> X<span class="token punctuation">)</span> -&gt; <span class="token punctuation">(</span><span class="token function">listof</span> X<span class="token punctuation">)</span></code></pre>
<p>It takes two inputs:</p><ol><li>A <strong>predicate function</strong>, i.e. a function that returns a boolean, and
</li>
<li>A <strong>list of elements</strong> to filter according to the predicate.
</li></ol>
<p>It returns a subset of the original list, consisting of <em>only those elements for which the predicate returned <code>true</code></em>.</p><pre><code class="lang-scheme">&gt; <span class="token punctuation">(</span><span class="token function">filter</span> even? <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">6</span><span class="token punctuation">)</span>

&gt; <span class="token punctuation">(</span><span class="token function">filter</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span>
            <span class="token punctuation">(</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token function">string-length</span> s<span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">&quot;a&quot;</span> <span class="token string">&quot;aa&quot;</span> <span class="token string">&quot;aaa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token string">&quot;aa&quot;</span> <span class="token string">&quot;aaa&quot;</span><span class="token punctuation">)</span></code></pre>
<h2 id="foldl-and-foldr"><code>foldl</code> and <code>foldr</code></h2><p>The <code>fold</code> functions <strong>collapses a list into a single object using a given function</strong>.</p><pre><code class="lang-scheme">foldl : <span class="token punctuation">(</span><span class="token function">X,</span> Y -&gt; Y<span class="token punctuation">)</span>, Y, <span class="token punctuation">(</span><span class="token function">listof</span> X<span class="token punctuation">)</span> -&gt; Y</code></pre>
<p>It&apos;s easiest to think about <code>foldl</code> as &quot;rolling a snowball&quot; through the list. At each item, we use the combiner function to add the current item to the snowball somehow. After we&apos;ve rolled the snowball all the way through the list, we return the snowball.</p><p>Let&apos;s unpack the above signature. <code>foldl</code> takes three arguments:</p><ol><li><p>A <strong>combiner function</strong> <code>(X, Y -&gt; Y)</code>, which will take two inputs:
 1. <code>X</code>, the current item from the <code>(listof X)</code>
 2. <code>Y</code>, the <strong>accumulator</strong> (our snowball), representing everything we&apos;ve gotten from combining the previous elements in the list</p><p>and combine them into the &quot;next&quot; <code>Y</code>.</p></li>
<li><p>An <strong>initializer</strong> of type <code>Y</code>, which represents the &quot;seed&quot; for our snowball; it&apos;s passed to the combiner function when <code>foldl</code> processes the very first list item.</p></li>
<li>A <strong>list</strong> of type <code>(listof X)</code> that we want to collapse.
</li></ol>
<p><code>foldr</code> works the same way as <code>foldl</code>, except it starts from the rightmost item and snowballs left.</p><pre><code class="lang-scheme">&gt; <span class="token punctuation">(</span><span class="token function">foldl</span> - <span class="token number">0</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">2</span>
&gt; <span class="token punctuation">(</span><span class="token function">foldr</span> - <span class="token number">0</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">-2</span></code></pre>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="2-Filter.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: filter">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Quiz 1 Review","level":"3.1","depth":1,"previous":{"title":"filter","level":"2.9","depth":1,"path":"2-Filter.md","ref":"2-Filter.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["prism","-highlight","katex"],"pluginsConfig":{"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":true},"prism":{"css":["prismjs/themes/prism.css"]},"katex":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"3-Quiz-1-Review.md","mtime":"2016-10-23T23:07:59.000Z","type":"markdown"},"gitbook":{"version":"3.2.0","time":"2016-10-23T23:15:09.783Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

