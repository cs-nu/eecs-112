
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <title>Quiz 2 Review Â· GitBook</title>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.0">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-prism/prism.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-katex/katex.min.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
        <link rel="stylesheet" href="styles/website.css">
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="6-Inheritance.html" />
    
    
    <link rel="prev" href="Quiz-1-Review.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                        <b>1.1.</b>
                    
                    Introduction
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Notes</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="0-Expressions-Calls.html">
            
                <a href="0-Expressions-Calls.html">
            
                    
                        <b>2.1.</b>
                    
                    Expressions and Function Calls
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="0-Function-Composition.html">
            
                <a href="0-Function-Composition.html">
            
                    
                        <b>2.2.</b>
                    
                    Function Composition
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="0-Types.html">
            
                <a href="0-Types.html">
            
                    
                        <b>2.3.</b>
                    
                    Types
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.4" data-path="0-Signatures.html">
            
                <a href="0-Signatures.html">
            
                    
                        <b>2.4.</b>
                    
                    Function Signatures
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.5" data-path="0-Exercises.html">
            
                <a href="0-Exercises.html">
            
                    
                        <b>2.5.</b>
                    
                    Exercises
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.6" data-path="1-Lambda.html">
            
                <a href="1-Lambda.html">
            
                    
                        <b>2.6.</b>
                    
                    Defining Functions
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.7" data-path="2-Structs-Lists.html">
            
                <a href="2-Structs-Lists.html">
            
                    
                        <b>2.7.</b>
                    
                    Structs and Lists
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.8" data-path="2-Map.html">
            
                <a href="2-Map.html">
            
                    
                        <b>2.8.</b>
                    
                    map
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.9" data-path="2-Filter.html">
            
                <a href="2-Filter.html">
            
                    
                        <b>2.9.</b>
                    
                    filter
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Review Sheets</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="Quiz-1-Review.html">
            
                <a href="Quiz-1-Review.html">
            
                    
                        <b>3.1.</b>
                    
                    Quiz 1 Review
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="3.2" data-path="Quiz-2-Review.html">
            
                <a href="Quiz-2-Review.html">
            
                    
                        <b>3.2.</b>
                    
                    Quiz 2 Review
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.3" data-path="6-Inheritance.html">
            
                <a href="6-Inheritance.html">
            
                    
                        <b>3.3.</b>
                    
                    Inheritance
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Quiz 2 Review</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <blockquote><p>As usual, this is not a comprehensive review sheet, nor is it &quot;official.&quot;</p></blockquote><h2 id="linked-lists">Linked Lists</h2><h3 id="accessing-parts-of-a-list-with-first-and-rest">Accessing parts of a list with <code>first</code> and <code>rest</code></h3><p>Recall that given any list, we can use <code>first</code> and <code>rest</code> to access its head and remainder, respectively:</p><pre class="language-"><code class="lang-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> my-list <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> true <span class="token string">&quot;hello&quot;</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token punctuation">(</span><span class="token function">first</span> my-list<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">; 1</span>
<span class="token punctuation">(</span><span class="token function">rest</span> my-list<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">; (list true &quot;hello&quot; 50)</span></code></pre>
<h3 id="lists-as-cons-pairs">Lists as <code>cons</code> pairs</h3><p>Until now, you&apos;ve been using lists as one-dimensional data structures:</p><pre class="language-"><code class="lang-scheme"><span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span></code></pre>
<p>It turns out that this <code>list</code> constructor function is just a convenient wrapper over the real structure of a list.</p><p>We use <code>cons</code> to build lists out of <strong>pairs</strong>, attaching a new item to an existing list:</p><pre class="language-"><code class="lang-scheme"><span class="token comment" spellcheck="true">; (list 1 2 3) is equivalent to</span>
<span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">1</span>
      <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">2</span>
            <span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">3</span> empty<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">; a single-element list</span>
<span class="token punctuation">(</span><span class="token builtin">cons</span> <span class="token number">3</span> empty<span class="token punctuation">)</span></code></pre>
<p>So lists are actually <em>nested pairs</em> like this:</p><pre class="language-"><code>+-----+-------------------------+
|     |-----+-----------------+ |
|     |     |-----+---------+ | |
|  1  |  2  |  3  |  empty  | | |
|     |     |-----+---------+ | |
|     |-----+-----------------+ |
+-----+-------------------------+
 first          rest</code></pre>
<p>Formally, a <strong>List-of-X</strong> is one of:</p><ul><li><code>empty</code>
</li>
<li><code>(cons X List-of-X)</code>
</li></ul>
<blockquote><p>Note that this is a <em>recursive</em> definition. A recursive definition uses the term being defined (in this case, <code>List-of-X</code>) within its definition (in this case, it&apos;s used in the second line, <code>(cons x List-of-X)</code>).</p></blockquote><h2 id="recursion">Recursion</h2><p>Since lists are recursive data structures, we can use recursive procedures to perform operations on them.</p><p>In general, a recursive procedure follows the structure</p><pre class="language-"><code class="lang-scheme"><span class="token punctuation">(</span><span class="token keyword">if</span> &lt;Base Case&gt;  <span class="token comment" spellcheck="true">; determined by the input type</span>
    &lt;Base Case Result&gt;  <span class="token comment" spellcheck="true">; determined by the output type</span>
    <span class="token punctuation">(</span><span class="token operator">&lt;</span>Combine&gt; &lt;Current Data&gt; &lt;Recursive Call with Remainder Data&gt;<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>Breaking things down further, the recursive call typically involves the following steps:</p><ol><li>Break the data into a &quot;current&quot; piece and a &quot;remainder&quot;
</li>
<li><strong>Handle</strong> the &quot;current&quot; piece according to the function
</li>
<li><strong>Recursively call your function</strong> with the &quot;remainder&quot; of the data
</li>
<li><strong>Combine</strong> the results from 1 and 2, and return this combination
</li></ol>
<h3 id="avoiding-infinite-loops">Avoiding infinite loops</h3><p>It is extremely important that your recursive call uses a <em>smaller</em> version of the original input data. Otherwise, you&apos;ll never reach your base case, and the function will recurse forever.</p><p>The following function loops forever:</p><pre class="language-"><code class="lang-scheme"><span class="token comment" spellcheck="true">; factorial/broken : number -&gt; number</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">factorial/broken</span> n<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true">; remember that 0! = 1 by definition</span>
      <span class="token punctuation">(</span><span class="token operator">*</span> n
         <span class="token punctuation">(</span><span class="token function">factorial/broken</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">; eek</span></code></pre>
<p>Once we fix our recursive call to operate on <code>(- n 1)</code>, it works:</p><pre class="language-"><code class="lang-scheme"><span class="token comment" spellcheck="true">; factorial : number -&gt; number</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">factorial</span> n<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">1</span>
      <span class="token punctuation">(</span><span class="token operator">*</span> n
         <span class="token punctuation">(</span><span class="token function">factorial</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">; much better</span></code></pre>
<h3 id="base-cases">Base Cases</h3><p>Here are some common base cases and combinations:</p><table>
<thead>
<tr><th>Type</th>
<th>Base Cases</th>
<th>Splitters</th>
<th>Combiners</th>
</tr></thead><tbody>
<tr><td>Number</td>
<td><code>0</code>, <code>1</code></td>
<td><code>-</code></td>
<td>Arithmetic operations (usually <code>+</code> or <code>*</code>), <code>max</code> and <code>min</code></td>
</tr><tr><td>String</td>
<td><code>&quot;&quot;</code></td>
<td><code>substring</code></td>
<td><code>string-append</code></td>
</tr><tr><td>List</td>
<td><code>empty</code></td>
<td><code>first</code> and <code>rest</code></td>
<td><code>cons</code>, (less frequently) <code>append</code></td>
</tr><tr><td>Image</td>
<td><code>empty-image</code></td>
<td>N/A (usually a return type)</td>
<td><code>overlay</code> and variants</td>
</tr></tbody></table>

<h3 id="examples-of-templates-for-recursion">Examples of templates for recursion</h3><p>These are all very general templates; you will almost never be able to follow them exactly, so memorizing them won&apos;t do you much good. However, they do provide examples of the base cases.</p><p>Note that the <code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Base</span> <span class="token attr-name">Case</span> <span class="token attr-name">Result</span><span class="token punctuation">&gt;</span></span></code> and <code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Combiner</span><span class="token punctuation">&gt;</span></span></code> depend on the output type, which is specified as <code>X</code> in all of the examples below.</p><h4 id="lists">Lists</h4><pre class="language-"><code class="lang-scheme"><span class="token comment" spellcheck="true">; List -&gt; X</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">recursive-lst-proc</span> lst<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">empty?</span> lst<span class="token punctuation">)</span> &lt;Base Case Result&gt;
      <span class="token punctuation">(</span><span class="token operator">&lt;</span>Combiner&gt; <span class="token punctuation">(</span><span class="token function">first</span> lst<span class="token punctuation">)</span>
                  <span class="token punctuation">(</span><span class="token function">recursive-lst-proc</span> <span class="token punctuation">(</span><span class="token function">rest</span> lst<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<h4 id="numbers">Numbers</h4><pre class="language-"><code class="lang-scheme"><span class="token comment" spellcheck="true">; Number -&gt; X</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">recursive-num-proc</span> n<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">=</span> n <span class="token number">0</span><span class="token punctuation">)</span> &lt;Base Case Result&gt;
      <span class="token punctuation">(</span><span class="token operator">&lt;</span>Combiner&gt; n
                  <span class="token punctuation">(</span><span class="token function">recursive-num-proc</span> <span class="token punctuation">(</span><span class="token operator">-</span> n <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<h4 id="trees">Trees</h4><pre class="language-"><code class="lang-scheme"><span class="token comment" spellcheck="true">; Tree -&gt; X</span>
<span class="token punctuation">(</span><span class="token keyword">define</span>-struct node <span class="token punctuation">(</span><span class="token function">value</span> children<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">recursive-tree-proc</span> t<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">empty?</span> t<span class="token punctuation">)</span> &lt;Base Case Result&gt;
      <span class="token punctuation">(</span><span class="token operator">&lt;</span>Combiner&gt; <span class="token punctuation">(</span><span class="token function">node-value</span> t<span class="token punctuation">)</span>
                  <span class="token punctuation">(</span><span class="token function">map</span> recursive-tree-proc <span class="token punctuation">(</span><span class="token function">node-children</span> t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<h2 id="iterative-recursion">Iterative Recursion</h2><p><strong>Iterative recursion</strong> is also called <strong>recursion with accumulators</strong> (and infrequently in this course, <strong>tail recursion</strong>).</p><p>The main difference between &quot;ordinary&quot; recursion and iterative recursion is that iterative recursion uses an <strong>accumulator</strong> as an additional input to the function.</p><p>This accumulator represents the &quot;partial result&quot; of the computation at the current position in the data. It allows the computer to represent the previously-seen data in a compact manner, by only remembering the &quot;relevant&quot; parts. (What&apos;s relevant is determined by the particular task of the function -- here are some examples:)</p><table>
<thead>
<tr><th>Input</th>
<th>Task</th>
<th>Accumulator</th>
</tr></thead><tbody>
<tr><td>List of numbers</td>
<td>Sum</td>
<td>Partial sum of all numbers seen so far</td>
</tr><tr><td>List of strings</td>
<td>Longest string</td>
<td>Longest string seen so far</td>
</tr><tr><td>List of numbers</td>
<td>List of all odd numbers</td>
<td>List of all odd numbers seen so far</td>
</tr></tbody></table>

<p>Here are two version of <code>sum-list</code>, written without and with accumulators.</p><pre class="language-"><code class="lang-scheme"><span class="token comment" spellcheck="true">; sum-list : List-of-Number -&gt; Number</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">sum-list</span> lon<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">empty?</span> lon<span class="token punctuation">)</span>
      <span class="token number">0</span>
      <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">first</span> lon<span class="token punctuation">)</span>
         <span class="token punctuation">(</span><span class="token function">sum-list</span> <span class="token punctuation">(</span><span class="token function">rest</span> lon<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">; sum-list/iter : List-of-Number -&gt; Number</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">sum-list/iter</span> lon acc<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">empty?</span> lon<span class="token punctuation">)</span>
      acc  <span class="token comment" spellcheck="true">; changed from 0</span>
      <span class="token punctuation">(</span><span class="token function">sum-list/iter</span> <span class="token punctuation">(</span><span class="token function">rest</span> lon<span class="token punctuation">)</span>
                     <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token punctuation">(</span><span class="token function">first</span> lon<span class="token punctuation">)</span> acc<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">; note that the (+ (first lon) ...) has been moved INSIDE the recursive call</span></code></pre>
<p>Here&apos;s a comparison of how the two functions are evaluated:</p><pre class="language-"><code class="lang-scheme"><span class="token comment" spellcheck="true">; Without accumulator</span>
<span class="token punctuation">(</span><span class="token function">sum-list</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">; With accumulator</span>
<span class="token punctuation">(</span><span class="token function">sum-list/iter</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span>
               <span class="token number">0</span><span class="token punctuation">)</span></code></pre>
<p>After one time step:</p><pre class="language-"><code class="lang-scheme"><span class="token comment" spellcheck="true">; Without accumulator</span>
<span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span>
   <span class="token punctuation">(</span><span class="token function">sum-list</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">; With accumulator</span>
<span class="token punctuation">(</span><span class="token function">sum-list/iter</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span>
               <span class="token number">1</span><span class="token punctuation">)</span></code></pre>
<p>After another step:</p><pre class="language-"><code class="lang-scheme"><span class="token comment" spellcheck="true">; Without accumulator: notice the &quot;trail&quot; growing...</span>
<span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span>
   <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">2</span>
      <span class="token punctuation">(</span><span class="token function">sum-list</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">; With accumulator: still nice and compact</span>
<span class="token punctuation">(</span><span class="token function">sum-list/iter</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">)</span>
               <span class="token number">3</span><span class="token punctuation">)</span></code></pre>
<pre class="language-"><code class="lang-scheme"><span class="token comment" spellcheck="true">; Without accumulator</span>
<span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span>
   <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">2</span>
      <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">3</span>
         <span class="token punctuation">(</span><span class="token function">sum-list</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">; With accumulator</span>
<span class="token punctuation">(</span><span class="token function">sum-list/iter</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">4</span><span class="token punctuation">)</span>
               <span class="token number">6</span><span class="token punctuation">)</span></code></pre>
<pre class="language-"><code class="lang-scheme"><span class="token comment" spellcheck="true">; Without accumulator</span>
<span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span>
   <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">2</span>
      <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">3</span>
         <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">4</span>
            <span class="token punctuation">(</span><span class="token function">sum-list</span> empty<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">; With accumulator</span>
<span class="token punctuation">(</span><span class="token function">sum-list/iter</span> empty
               <span class="token number">10</span><span class="token punctuation">)</span></code></pre>
<pre class="language-"><code class="lang-scheme"><span class="token comment" spellcheck="true">; Without accumulator</span>
<span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">1</span>
   <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">2</span>
      <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">3</span>
         <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">4</span>
            empty<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">; With accumulator</span>
<span class="token number">10</span></code></pre>
<p>Evidently, iterative recursion is <em>far more efficient</em> than regular recursion. That&apos;s because the accumulator is basically a <em>compact encoding of everything the program needs to know about the previously-seen data</em>, so we don&apos;t need to remember all the data itself.</p><h2 id="imperative-programming">Imperative Programming</h2><p><strong>Imperative programming</strong> is a style of programming characterized by providing the computer simple, detailed instructions for everything.</p><table>
<thead>
<tr><th>Functional</th>
<th>Imperative</th>
</tr></thead><tbody>
<tr><td>Functions almost always <strong>take inputs</strong></td>
<td>Functions <strong>may not</strong> take any inputs</td>
</tr><tr><td>Functions <strong>always</strong> have return values</td>
<td>Functions <strong>may not</strong> have any return value (i.e. they may return <code>void</code>)</td>
</tr><tr><td>Functions always return the <strong>same output</strong> for a particular input</td>
<td>Functions are allowed to return <strong>whatever they want</strong>, or nothing at all</td>
</tr><tr><td>Use <strong>recursion</strong> to traverse structures</td>
<td>Use <strong>iteration</strong> to traverse structures</td>
</tr><tr><td>Variables never change values (they are &quot;<strong>immutable</strong>&quot;)</td>
<td>Variables can change values (they are &quot;<strong>mutable</strong>&quot;)</td>
</tr><tr><td>Functions <strong>never affect things outside</strong> their scope</td>
<td>Functions have &quot;<strong>side effects</strong>&quot;</td>
</tr></tbody></table>

<p>Here are the main imperative functions you should understand:</p><h3 id="do-nothing">Do nothing</h3><pre class="language-"><code class="lang-scheme"><span class="token punctuation">(</span>void<span class="token punctuation">)</span></code></pre>
<p>Does nothing. If a function doesn&apos;t return any values, we say it &quot;returns <code>(void)</code>&quot;.</p><h3 id="conditionally-do-nothing">Conditionally do nothing</h3><pre class="language-"><code class="lang-scheme"><span class="token punctuation">(</span><span class="token function">when</span> &lt;Condition&gt; &lt;Result&gt;<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token function">unless</span> &lt;Condition&gt; &lt;Result&gt;<span class="token punctuation">)</span></code></pre>
<p><code>when</code> executes <code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Result</span><span class="token punctuation">&gt;</span></span></code> if and only if <code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Condition</span><span class="token punctuation">&gt;</span></span></code> is true. <code>unless</code> does the opposite.</p><blockquote><p><strong>Fun fact:</strong> the funnest fact.</p><pre class="language-"><code class="lang-scheme"><span class="token comment" spellcheck="true">; (when &lt;Condition&gt; &lt;Result&gt;) is equivalent to</span>
<span class="token punctuation">(</span><span class="token keyword">if</span> &lt;Condition&gt;
    &lt;Result&gt;
    <span class="token punctuation">(</span>void<span class="token punctuation">)</span><span class="token punctuation">)</span>
    
<span class="token comment" spellcheck="true">; (unless &lt;Condition&gt; &lt;Result&gt;) is equivalent to</span>
<span class="token punctuation">(</span><span class="token keyword">if</span> &lt;Condition&gt;
    <span class="token punctuation">(</span>void<span class="token punctuation">)</span>
    &lt;Result&gt;<span class="token punctuation">)</span></code></pre>
</blockquote><h3 id="do-a-sequence-of-instructions">Do a sequence of instructions</h3><pre class="language-"><code class="lang-scheme"><span class="token punctuation">(</span><span class="token keyword">begin</span>
  &lt;FunctionCall#1&gt;
  &lt;FunctionCall#2&gt;
  ...
  &lt;ReturnFunctionCall&gt;<span class="token punctuation">)</span></code></pre>
<p>Executes a sequence of function calls, one at a time, and returns the value of the last one.</p><h3 id="mutate-variables">Mutate variables</h3><pre class="language-"><code class="lang-scheme"><span class="token punctuation">(</span><span class="token keyword">set!</span> &lt;Variable Name&gt; &lt;New Value&gt;<span class="token punctuation">)</span></code></pre>
<p>Note that <code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Variable</span> <span class="token attr-name">Name</span><span class="token punctuation">&gt;</span></span></code> must previously have been <code>defined</code>.</p><h3 id="iteratively-traverse-a-list">Iteratively traverse a list</h3><pre class="language-"><code class="lang-scheme"><span class="token punctuation">(</span><span class="token function">for-each</span> proc lst<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">; if lst is a List-of-X, then proc must take an input of type X</span></code></pre>
<p>Just like <code>map</code>, in that it calls <code>proc</code> with each item in order, but <em>does not</em> return the resulting list.</p><blockquote><p><strong>Warning:</strong> 
Remember to use <code>for-each</code> with a <code>proc</code> that performs some kind of mutation (or causes a side effect). If <code>proc</code> just returns a new value, that value will disappear into the void, since <code>for-each</code> doesn&apos;t return anything.</p><pre class="language-"><code class="lang-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> my-list <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">doubler</span> n<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token number">2</span> n<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token punctuation">(</span><span class="token function">for-each</span> doubler my-list<span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">; my-list is still (list 1 2 3)</span></code></pre>
</blockquote><h3 id="what-you-should-know">What you should know</h3><p>Understand how side effects work, and how to translate functional-style code into its imperative equivalents.</p><p>Here&apos;s an example: the inimitable <code>sum-list</code>, written imperatively, with and without <code>for-each</code>.</p><pre class="language-"><code class="lang-scheme"><span class="token comment" spellcheck="true">; sum-list/imperative : (listof number) -&gt; number</span>
<span class="token comment" spellcheck="true">; sums a list imperatively</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">sum-list/imperative</span> lon<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token function">local</span> [<span class="token punctuation">(</span><span class="token keyword">define</span> sum <span class="token number">0</span><span class="token punctuation">)</span>

          <span class="token punctuation">(</span><span class="token keyword">define</span> remaining lon<span class="token punctuation">)</span>

          <span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span>loop<span class="token punctuation">)</span>
            <span class="token punctuation">(</span><span class="token keyword">if</span>
             <span class="token comment" spellcheck="true">; If remaining is an empty list, return sum</span>
             <span class="token punctuation">(</span><span class="token function">empty?</span> remaining<span class="token punctuation">)</span> sum

             <span class="token comment" spellcheck="true">; Otherwise...</span>
             <span class="token punctuation">(</span><span class="token keyword">begin</span>
               <span class="token comment" spellcheck="true">; First, update the value of sum</span>
               <span class="token punctuation">(</span><span class="token keyword">set!</span> sum <span class="token punctuation">(</span><span class="token operator">+</span> sum <span class="token punctuation">(</span><span class="token function">first</span> remaining<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
               <span class="token comment" spellcheck="true">; Next, update the remaining list</span>
               <span class="token punctuation">(</span><span class="token keyword">set!</span> remaining <span class="token punctuation">(</span><span class="token function">rest</span> remaining<span class="token punctuation">)</span><span class="token punctuation">)</span>
               <span class="token comment" spellcheck="true">; Finally, repeat</span>
               <span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>]
    <span class="token comment" spellcheck="true">; Kick off the loop</span>
    <span class="token punctuation">(</span>loop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">; sum-list/for-each : (listof numbers) -&gt; number</span>
<span class="token comment" spellcheck="true">; sums a list imperatively</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">sum-list/for-each</span> lon<span class="token punctuation">)</span>
  <span class="token punctuation">(</span><span class="token function">local</span> [<span class="token comment" spellcheck="true">; Initialize the sum to zero</span>
          <span class="token punctuation">(</span><span class="token keyword">define</span> sum <span class="token number">0</span><span class="token punctuation">)</span>]

    <span class="token punctuation">(</span><span class="token keyword">begin</span>
      <span class="token comment" spellcheck="true">; Loop through the list, adding each item to the sum</span>
      <span class="token punctuation">(</span><span class="token function">for-each</span> <span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">(</span>item<span class="token punctuation">)</span>
                  <span class="token punctuation">(</span><span class="token keyword">set!</span> sum <span class="token punctuation">(</span><span class="token operator">+</span> sum item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                lon<span class="token punctuation">)</span>

      <span class="token comment" spellcheck="true">; After we&apos;re done looping, return the sum</span>
      sum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment" spellcheck="true">; Using for-each works the same way as before</span>
<span class="token punctuation">(</span><span class="token function">check-expect</span> <span class="token punctuation">(</span><span class="token function">sum-list/for-each</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
              <span class="token punctuation">(</span><span class="token function">sum-list</span> <span class="token punctuation">(</span><span class="token builtin">list</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<h2 id="structs-and-mutation">Structs and mutation</h2><p>Recall that structs have &quot;accessor&quot; functions for each of their fields:</p><pre class="language-"><code class="lang-scheme"><span class="token punctuation">(</span><span class="token operator">&lt;</span>Struct Name&gt;-&lt;Field Name&gt; &lt;Instance of Struct&gt;<span class="token punctuation">)</span></code></pre>
<pre class="language-"><code class="lang-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span>-struct person <span class="token punctuation">(</span><span class="token function">name</span> age<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">; name is a string</span>
<span class="token comment" spellcheck="true">; age is a number</span>

<span class="token punctuation">(</span><span class="token keyword">define</span> wizard <span class="token punctuation">(</span><span class="token function">make-struct</span> <span class="token string">&quot;Harry Potter&quot;</span> <span class="token number">17</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token punctuation">(</span><span class="token function">person-name</span> wizard<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">; &quot;Harry Potter&quot;</span></code></pre>
<p>Just as we can use <code>set!</code> to mutate previously-defined variables, we can <em>mutate the fields of structs</em>.</p><pre class="language-"><code class="lang-scheme"><span class="token punctuation">(</span><span class="token function">set-&lt;Struct</span> Name&gt;-&lt;Field-Name&gt;! &lt;Instance of Struct&gt; &lt;New Field Value&gt;<span class="token punctuation">)</span></code></pre>
<pre class="language-"><code class="lang-scheme"><span class="token comment" spellcheck="true">; Continuing the above example...</span>

<span class="token punctuation">(</span><span class="token function">person-name</span> wizard<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">; &quot;Harry Potter&quot;</span>

<span class="token punctuation">(</span><span class="token function">set-person-name!</span> wizard <span class="token string">&quot;Ron Weasley&quot;</span><span class="token punctuation">)</span>

<span class="token punctuation">(</span><span class="token function">person-name</span> wizard<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">; &quot;Ron Weasley&quot;</span></code></pre>
<h2 id="what-else">What else?</h2><p>Things that might be helpful to brush up on:</p><ul><li>Type signatures and consistency (this will never <em>not</em> be important)
</li>
<li>Grammar rules of Racket
</li>
<li>Local scope (<code>local</code>)
</li>
<li>Basics of how structs work
</li></ul>
<p>Ways to evaluate your preparedness:</p><ul><li><p>Can you do all of the homeworks/tutorials since the last midterm?</p><ul><li>Not because we&apos;re going to pop some wild evolutionary tree question on you, but because they&apos;re good applications of the course material (and good examples of how we write questions!)
</li></ul>
</li>
<li><p>Can you write your own implementations of <code>map</code>, <code>filter</code>, <code>foldl</code>, <code>ormap</code>, etc. using both recursion and imperative iteration?</p></li></ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="Quiz-1-Review.html" class="navigation navigation-prev " aria-label="Previous page: Quiz 1 Review">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="6-Inheritance.html" class="navigation navigation-next " aria-label="Next page: Inheritance">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Quiz 2 Review","author":"Sarah Lim","date":"Fall 2016","level":"3.2","depth":1,"next":{"title":"Inheritance","level":"3.3","depth":1,"path":"6-Inheritance.md","ref":"6-Inheritance.md","articles":[]},"previous":{"title":"Quiz 1 Review","level":"3.1","depth":1,"path":"Quiz-1-Review.md","ref":"Quiz-1-Review.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["prism","-highlight","katex"],"pluginsConfig":{"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":true},"prism":{"css":["prismjs/themes/prism.css"]},"katex":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"Quiz-2-Review.md","mtime":"2016-12-01T00:49:41.000Z","type":"markdown"},"gitbook":{"version":"3.2.0","time":"2018-01-27T22:24:53.820Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

